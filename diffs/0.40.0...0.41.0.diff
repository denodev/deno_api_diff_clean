diff --git a/lib.deno.ns.d.ts b/lib.deno.ns.d.ts
index e4a1d6e..48b6c66 100644
--- a/lib.deno.ns.d.ts
+++ b/lib.deno.ns.d.ts
@@ -194,17 +194,7 @@ declare namespace Deno {
     mode?: number;
   }
   export function mkdirSync(path: string, options?: MkdirOptions): void;
-  export function mkdirSync(
-    path: string,
-    recursive?: boolean,
-    mode?: number,
-  ): void;
   export function mkdir(path: string, options?: MkdirOptions): Promise<void>;
-  export function mkdir(
-    path: string,
-    recursive?: boolean,
-    mode?: number,
-  ): Promise<void>;
   export interface MakeTempOptions {
     dir?: string;
     prefix?: string;
@@ -238,11 +228,13 @@ declare namespace Deno {
   export function readFileSync(path: string): Uint8Array;
   export function readFile(path: string): Promise<Uint8Array>;
   export interface FileInfo {
+    isFile: boolean;
+    isDirectory: boolean;
+    isSymlink: boolean;
     size: number;
     modified: number | null;
     accessed: number | null;
     created: number | null;
-    name: string | null;
     dev: number | null;
     ino: number | null;
     mode: number | null;
@@ -252,14 +244,14 @@ declare namespace Deno {
     rdev: number | null;
     blksize: number | null;
     blocks: number | null;
-    isFile(): boolean;
-    isDirectory(): boolean;
-    isSymlink(): boolean;
   }
   export function realpathSync(path: string): string;
   export function realpath(path: string): Promise<string>;
-  export function readdirSync(path: string): FileInfo[];
-  export function readdir(path: string): Promise<FileInfo[]>;
+  export interface DirEntry extends FileInfo {
+    name: string;
+  }
+  export function readdirSync(path: string): Iterable<DirEntry>;
+  export function readdir(path: string): AsyncIterable<DirEntry>;
   export function copyFileSync(fromPath: string, toPath: string): void;
   export function copyFile(fromPath: string, toPath: string): Promise<void>;
   export function readlinkSync(path: string): string;
@@ -296,9 +288,9 @@ declare namespace Deno {
     options?: WriteFileOptions,
   ): Promise<void>;
   interface Location {
-    filename: string;
-    line: number;
-    column: number;
+    fileName: string;
+    lineNumber: number;
+    columnNumber: number;
   }
   export function applySourceMap(location: Location): Location;
   export const errors: {
@@ -319,6 +311,7 @@ declare namespace Deno {
     UnexpectedEof: ErrorConstructor;
     BadResource: ErrorConstructor;
     Http: ErrorConstructor;
+    Busy: ErrorConstructor;
   };
   export type PermissionName =
     | "run"
@@ -405,13 +398,13 @@ declare namespace Deno {
     send(p: Uint8Array, addr: Addr): Promise<void>;
     close(): void;
     readonly addr: Addr;
-    [Symbol.asyncIterator](): AsyncIterator<[Uint8Array, Addr]>;
+    [Symbol.asyncIterator](): AsyncIterableIterator<[Uint8Array, Addr]>;
   }
   export interface Listener extends AsyncIterable<Conn> {
     accept(): Promise<Conn>;
     close(): void;
     readonly addr: Addr;
-    [Symbol.asyncIterator](): AsyncIterator<Conn>;
+    [Symbol.asyncIterator](): AsyncIterableIterator<Conn>;
   }
   export interface Conn extends Reader, Writer, Closer {
     readonly localAddr: Addr;
@@ -503,11 +496,17 @@ declare namespace Deno {
     close(): void;
     kill(signo: number): void;
   }
-  export interface ProcessStatus {
-    success: boolean;
-    code?: number;
-    signal?: number;
-  }
+  export type ProcessStatus =
+    | {
+      success: true;
+      code: 0;
+      signal?: undefined;
+    }
+    | {
+      success: false;
+      code: number;
+      signal?: number;
+    };
   export interface RunOptions {
     cmd: string[];
     cwd?: string;
@@ -688,8 +687,6 @@ declare namespace Deno {
     outDir?: string;
     paths?: Record<string, string[]>;
     preserveConstEnums?: boolean;
-    removeComments?: boolean;
-    resolveJsonModule?: boolean;
     rootDir?: string;
     rootDirs?: string[];
     sourceMap?: boolean;
diff --git a/lib.deno.shared_globals.d.ts b/lib.deno.shared_globals.d.ts
index d62f503..b7bfe23 100644
--- a/lib.deno.shared_globals.d.ts
+++ b/lib.deno.shared_globals.d.ts
@@ -1,25 +1,10 @@
-declare interface WindowOrWorkerGlobalScope {
-  fetch: typeof __fetch.fetch;
-  File: __domTypes.DomFileConstructor;
-  CustomEvent: typeof __customEvent.CustomEvent;
-  Event: typeof __event.Event;
-  EventTarget: typeof __eventTarget.EventTarget;
-  Headers: __domTypes.HeadersConstructor;
-  FormData: __domTypes.FormDataConstructor;
-  ReadableStream: __domTypes.ReadableStreamConstructor;
-  Request: __domTypes.RequestConstructor;
-  Response: typeof __fetch.Response;
-  location: __domTypes.Location;
-}
 declare namespace WebAssembly {
   interface WebAssemblyInstantiatedSource {
     module: Module;
     instance: Instance;
   }
   function compile(bufferSource: BufferSource): Promise<Module>;
-  function compileStreaming(
-    source: Promise<__domTypes.Response>,
-  ): Promise<Module>;
+  function compileStreaming(source: Promise<Response>): Promise<Module>;
   function instantiate(
     bufferSource: BufferSource,
     importObject?: object,
@@ -29,7 +14,7 @@ declare namespace WebAssembly {
     importObject?: object,
   ): Promise<Instance>;
   function instantiateStreaming(
-    source: Promise<__domTypes.Response>,
+    source: Promise<Response>,
     importObject?: object,
   ): Promise<WebAssemblyInstantiatedSource>;
   function validate(bufferSource: BufferSource): boolean;
@@ -98,7 +83,6 @@ declare namespace WebAssembly {
     constructor(message: string, fileName?: string, lineNumber?: string);
   }
 }
-declare const fetch: typeof __fetch.fetch;
 declare function setTimeout(
   cb: (...args: unknown[]) => void,
   delay?: number,
@@ -112,458 +96,118 @@ declare function setInterval(
 declare function clearTimeout(id?: number): void;
 declare function clearInterval(id?: number): void;
 declare function queueMicrotask(func: Function): void;
-declare const console: Console;
-declare const File: __domTypes.DomFileConstructor;
-declare const CustomEventInit: typeof __customEvent.CustomEventInit;
-declare const CustomEvent: typeof __customEvent.CustomEvent;
-declare const EventInit: typeof __event.EventInit;
-declare const Event: typeof __event.Event;
-declare const EventListener: __domTypes.EventListener;
-declare const EventTarget: typeof __eventTarget.EventTarget;
-declare const Headers: __domTypes.HeadersConstructor;
-declare const location: __domTypes.Location;
-declare const FormData: __domTypes.FormDataConstructor;
-declare const ReadableStream: __domTypes.ReadableStreamConstructor;
-declare const Request: __domTypes.RequestConstructor;
-declare const Response: typeof __fetch.Response;
+declare var console: Console;
+declare var location: Location;
 declare function addEventListener(
   type: string,
-  callback: __domTypes.EventListenerOrEventListenerObject | null,
-  options?: boolean | __domTypes.AddEventListenerOptions | undefined,
+  callback: EventListenerOrEventListenerObject | null,
+  options?: boolean | AddEventListenerOptions | undefined,
 ): void;
-declare function dispatchEvent(event: __domTypes.Event): boolean;
+declare function dispatchEvent(event: Event): boolean;
 declare function removeEventListener(
   type: string,
-  callback: __domTypes.EventListenerOrEventListenerObject | null,
-  options?: boolean | __domTypes.EventListenerOptions | undefined,
+  callback: EventListenerOrEventListenerObject | null,
+  options?: boolean | EventListenerOptions | undefined,
 ): void;
-declare type Body = __domTypes.Body;
-declare type File = __domTypes.DomFile;
-declare type CustomEventInit = __domTypes.CustomEventInit;
-declare type CustomEvent = __domTypes.CustomEvent;
-declare type EventInit = __domTypes.EventInit;
-declare type Event = __domTypes.Event;
-declare type EventListener = __domTypes.EventListener;
-declare type EventTarget = __domTypes.EventTarget;
-declare type Headers = __domTypes.Headers;
-declare type FormData = __domTypes.FormData;
-declare type ReadableStream<R = any> = __domTypes.ReadableStream<R>;
-declare type Request = __domTypes.Request;
-declare type Response = __domTypes.Response;
 declare interface ImportMeta {
   url: string;
   main: boolean;
 }
-declare namespace __domTypes {
-  export type HeadersInit =
-    | Headers
-    | Array<[string, string]>
-    | Record<string, string>;
-  type BodyInit =
-    | Blob
-    | BufferSource
-    | FormData
-    | URLSearchParams
-    | ReadableStream
-    | string;
-  export type RequestInfo = Request | string;
-  type ReferrerPolicy =
-    | ""
-    | "no-referrer"
-    | "no-referrer-when-downgrade"
-    | "origin-only"
-    | "origin-when-cross-origin"
-    | "unsafe-url";
-  export type FormDataEntryValue = DomFile | string;
-  export interface DomIterable<K, V> {
-    keys(): IterableIterator<K>;
-    values(): IterableIterator<V>;
-    entries(): IterableIterator<[K, V]>;
-    [Symbol.iterator](): IterableIterator<[K, V]>;
-    forEach(
-      callback: (value: V, key: K, parent: this) => void,
-      thisArg?: any,
-    ): void;
-  }
-  interface AbortSignalEventMap {
-    abort: ProgressEvent;
-  }
-  export enum NodeType {
-    ELEMENT_NODE = 1,
-    TEXT_NODE = 3,
-    DOCUMENT_FRAGMENT_NODE = 11,
-  }
-  export interface EventListener {
-    (evt: Event): void | Promise<void>;
-  }
-  export interface EventListenerObject {
-    handleEvent(evt: Event): void | Promise<void>;
-  }
-  export type EventListenerOrEventListenerObject =
-    | EventListener
-    | EventListenerObject;
-  export interface EventTargetListener {
-    callback: EventListenerOrEventListenerObject;
-    options: AddEventListenerOptions;
-  }
-  export const eventTargetHost: unique symbol;
-  export const eventTargetListeners: unique symbol;
-  export const eventTargetMode: unique symbol;
-  export const eventTargetNodeType: unique symbol;
-  export interface EventTarget {
-    addEventListener(
-      type: string,
-      callback: EventListenerOrEventListenerObject | null,
-      options?: boolean | AddEventListenerOptions,
-    ): void;
-    dispatchEvent(event: Event): boolean;
-    removeEventListener(
-      type: string,
-      callback?: EventListenerOrEventListenerObject | null,
-      options?: EventListenerOptions | boolean,
-    ): void;
-  }
-  export interface ProgressEventInit extends EventInit {
-    lengthComputable?: boolean;
-    loaded?: number;
-    total?: number;
-  }
-  export interface EventInit {
-    bubbles?: boolean;
-    cancelable?: boolean;
-    composed?: boolean;
-  }
-  export interface CustomEventInit extends EventInit {
-    detail?: any;
-  }
-  export enum EventPhase {
-    NONE = 0,
-    CAPTURING_PHASE = 1,
-    AT_TARGET = 2,
-    BUBBLING_PHASE = 3,
-  }
-  export interface EventPath {
-    item: EventTarget;
-    itemInShadowTree: boolean;
-    relatedTarget: EventTarget | null;
-    rootOfClosedTree: boolean;
-    slotInClosedTree: boolean;
-    target: EventTarget | null;
-    touchTargetList: EventTarget[];
-  }
-  export interface Event {
-    readonly type: string;
-    target: EventTarget | null;
-    currentTarget: EventTarget | null;
-    composedPath(): EventPath[];
-    eventPhase: number;
-    stopPropagation(): void;
-    stopImmediatePropagation(): void;
-    readonly bubbles: boolean;
-    readonly cancelable: boolean;
-    preventDefault(): void;
-    readonly defaultPrevented: boolean;
-    readonly composed: boolean;
-    isTrusted: boolean;
-    readonly timeStamp: Date;
-    dispatched: boolean;
-    readonly initialized: boolean;
-    inPassiveListener: boolean;
-    cancelBubble: boolean;
-    cancelBubbleImmediately: boolean;
-    path: EventPath[];
-    relatedTarget: EventTarget | null;
-  }
-  export interface CustomEvent extends Event {
-    readonly detail: any;
-    initCustomEvent(
-      type: string,
-      bubbles?: boolean,
-      cancelable?: boolean,
-      detail?: any | null,
-    ): void;
-  }
-  export interface DomFile extends Blob {
-    readonly lastModified: number;
-    readonly name: string;
-  }
-  export interface DomFileConstructor {
-    new (
-      bits: BlobPart[],
-      filename: string,
-      options?: FilePropertyBag,
-    ): DomFile;
-    prototype: DomFile;
-  }
-  export interface FilePropertyBag extends BlobPropertyBag {
-    lastModified?: number;
-  }
-  interface ProgressEvent extends Event {
-    readonly lengthComputable: boolean;
-    readonly loaded: number;
-    readonly total: number;
-  }
-  export interface EventListenerOptions {
-    capture?: boolean;
-  }
-  export interface AddEventListenerOptions extends EventListenerOptions {
-    once?: boolean;
-    passive?: boolean;
-  }
-  interface AbortSignal extends EventTarget {
-    readonly aborted: boolean;
-    onabort: ((this: AbortSignal, ev: ProgressEvent) => any) | null;
-    addEventListener<K extends keyof AbortSignalEventMap>(
-      type: K,
-      listener: (this: AbortSignal, ev: AbortSignalEventMap[K]) => any,
-      options?: boolean | AddEventListenerOptions,
-    ): void;
-    addEventListener(
-      type: string,
-      listener: EventListener,
-      options?: boolean | AddEventListenerOptions,
-    ): void;
-    removeEventListener<K extends keyof AbortSignalEventMap>(
-      type: K,
-      listener: (this: AbortSignal, ev: AbortSignalEventMap[K]) => any,
-      options?: boolean | EventListenerOptions,
-    ): void;
-    removeEventListener(
-      type: string,
-      listener: EventListener,
-      options?: boolean | EventListenerOptions,
-    ): void;
-  }
-  export interface ReadableStreamReadDoneResult<T> {
-    done: true;
-    value?: T;
-  }
-  export interface ReadableStreamReadValueResult<T> {
-    done: false;
-    value: T;
-  }
-  export type ReadableStreamReadResult<T> =
-    | ReadableStreamReadValueResult<T>
-    | ReadableStreamReadDoneResult<T>;
-  export interface ReadableStreamDefaultReader<R = any> {
-    readonly closed: Promise<void>;
-    cancel(reason?: any): Promise<void>;
-    read(): Promise<ReadableStreamReadResult<R>>;
-    releaseLock(): void;
-  }
-  export interface PipeOptions {
-    preventAbort?: boolean;
-    preventCancel?: boolean;
-    preventClose?: boolean;
-    signal?: AbortSignal;
-  }
-  export interface UnderlyingSource<R = any> {
-    cancel?: ReadableStreamErrorCallback;
-    pull?: ReadableStreamDefaultControllerCallback<R>;
-    start?: ReadableStreamDefaultControllerCallback<R>;
-    type?: undefined;
-  }
-  export interface ReadableStreamErrorCallback {
-    (reason: any): void | PromiseLike<void>;
-  }
-  export interface ReadableStreamDefaultControllerCallback<R> {
-    (controller: ReadableStreamDefaultController<R>): void | PromiseLike<void>;
-  }
-  export interface ReadableStreamDefaultController<R> {
-    readonly desiredSize: number;
-    enqueue(chunk?: R): void;
-    close(): void;
-    error(e?: any): void;
-  }
-  export interface ReadableStream<R = any> {
-    readonly locked: boolean;
-    cancel(reason?: any): Promise<void>;
-    getReader(options: { mode: "byob" }): ReadableStreamBYOBReader;
-    getReader(): ReadableStreamDefaultReader<R>;
-    tee(): [ReadableStream<R>, ReadableStream<R>];
-  }
-  export interface ReadableStreamConstructor<R = any> {
-    new (src?: UnderlyingSource<R>): ReadableStream<R>;
-    prototype: ReadableStream<R>;
-  }
-  export interface ReadableStreamReader<R = any> {
-    cancel(reason: any): Promise<void>;
-    read(): Promise<ReadableStreamReadResult<R>>;
-    releaseLock(): void;
-  }
-  export interface ReadableStreamBYOBReader {
-    readonly closed: Promise<void>;
-    cancel(reason?: any): Promise<void>;
-    read<T extends ArrayBufferView>(
-      view: T,
-    ): Promise<ReadableStreamReadResult<T>>;
-    releaseLock(): void;
-  }
-  export interface WritableStream<W = any> {
-    readonly locked: boolean;
-    abort(reason?: any): Promise<void>;
-    getWriter(): WritableStreamDefaultWriter<W>;
-  }
-  export interface WritableStreamDefaultWriter<W = any> {
-    readonly closed: Promise<void>;
-    readonly desiredSize: number | null;
-    readonly ready: Promise<void>;
-    abort(reason?: any): Promise<void>;
-    close(): Promise<void>;
-    releaseLock(): void;
-    write(chunk: W): Promise<void>;
-  }
-  export interface FormData extends DomIterable<string, FormDataEntryValue> {
-    append(name: string, value: string | Blob, fileName?: string): void;
-    delete(name: string): void;
-    get(name: string): FormDataEntryValue | null;
-    getAll(name: string): FormDataEntryValue[];
-    has(name: string): boolean;
-    set(name: string, value: string | Blob, fileName?: string): void;
-  }
-  export interface FormDataConstructor {
-    new (): FormData;
-    prototype: FormData;
-  }
-  export interface Body {
-    readonly body: ReadableStream<Uint8Array> | null;
-    readonly bodyUsed: boolean;
-    arrayBuffer(): Promise<ArrayBuffer>;
-    blob(): Promise<Blob>;
-    formData(): Promise<FormData>;
-    json(): Promise<any>;
-    text(): Promise<string>;
-  }
-  export interface Headers extends DomIterable<string, string> {
-    append(name: string, value: string): void;
-    delete(name: string): void;
-    entries(): IterableIterator<[string, string]>;
-    get(name: string): string | null;
-    has(name: string): boolean;
-    keys(): IterableIterator<string>;
-    set(name: string, value: string): void;
-    values(): IterableIterator<string>;
-    forEach(
-      callbackfn: (value: string, key: string, parent: this) => void,
-      thisArg?: any,
-    ): void;
-    [Symbol.iterator](): IterableIterator<[string, string]>;
-  }
-  export interface HeadersConstructor {
-    new (init?: HeadersInit): Headers;
-    prototype: Headers;
-  }
-  type RequestCache =
-    | "default"
-    | "no-store"
-    | "reload"
-    | "no-cache"
-    | "force-cache"
-    | "only-if-cached";
-  type RequestCredentials = "omit" | "same-origin" | "include";
-  type RequestDestination =
-    | ""
-    | "audio"
-    | "audioworklet"
-    | "document"
-    | "embed"
-    | "font"
-    | "image"
-    | "manifest"
-    | "object"
-    | "paintworklet"
-    | "report"
-    | "script"
-    | "sharedworker"
-    | "style"
-    | "track"
-    | "video"
-    | "worker"
-    | "xslt";
-  type RequestMode = "navigate" | "same-origin" | "no-cors" | "cors";
-  type RequestRedirect = "follow" | "error" | "manual";
-  type ResponseType =
-    | "basic"
-    | "cors"
-    | "default"
-    | "error"
-    | "opaque"
-    | "opaqueredirect";
-  export interface RequestInit {
-    body?: BodyInit | null;
-    cache?: RequestCache;
-    credentials?: RequestCredentials;
-    headers?: HeadersInit;
-    integrity?: string;
-    keepalive?: boolean;
-    method?: string;
-    mode?: RequestMode;
-    redirect?: RequestRedirect;
-    referrer?: string;
-    referrerPolicy?: ReferrerPolicy;
-    signal?: AbortSignal | null;
-    window?: any;
-  }
-  export interface ResponseInit {
-    headers?: HeadersInit;
-    status?: number;
-    statusText?: string;
-  }
-  export interface RequestConstructor {
-    new (input: RequestInfo, init?: RequestInit): Request;
-    prototype: Request;
-  }
-  export interface Request extends Body {
-    readonly cache?: RequestCache;
-    readonly credentials?: RequestCredentials;
-    readonly destination?: RequestDestination;
-    readonly headers: Headers;
-    readonly integrity?: string;
-    readonly isHistoryNavigation?: boolean;
-    readonly isReloadNavigation?: boolean;
-    readonly keepalive?: boolean;
-    readonly method: string;
-    readonly mode?: RequestMode;
-    readonly redirect?: RequestRedirect;
-    readonly referrer?: string;
-    readonly referrerPolicy?: ReferrerPolicy;
-    readonly signal?: AbortSignal;
-    readonly url: string;
-    clone(): Request;
-  }
-  export interface Response extends Body {
-    readonly headers: Headers;
-    readonly ok: boolean;
-    readonly redirected: boolean;
-    readonly status: number;
-    readonly statusText: string;
-    readonly trailer: Promise<Headers>;
-    readonly type: ResponseType;
-    readonly url: string;
-    clone(): Response;
-  }
-  export interface DOMStringList {
-    readonly length: number;
-    contains(string: string): boolean;
-    item(index: number): string | null;
-    [index: number]: string;
-  }
-  export interface Location {
-    readonly ancestorOrigins: DOMStringList;
-    hash: string;
-    host: string;
-    hostname: string;
-    href: string;
-    toString(): string;
-    readonly origin: string;
-    pathname: string;
-    port: string;
-    protocol: string;
-    search: string;
-    assign(url: string): void;
-    reload(): void;
-    replace(url: string): void;
-  }
+interface DomIterable<K, V> {
+  keys(): IterableIterator<K>;
+  values(): IterableIterator<V>;
+  entries(): IterableIterator<[K, V]>;
+  [Symbol.iterator](): IterableIterator<[K, V]>;
+  forEach(
+    callback: (value: V, key: K, parent: this) => void,
+    thisArg?: any,
+  ): void;
+}
+interface ReadableStreamReadDoneResult<T> {
+  done: true;
+  value?: T;
+}
+interface ReadableStreamReadValueResult<T> {
+  done: false;
+  value: T;
+}
+type ReadableStreamReadResult<T> =
+  | ReadableStreamReadValueResult<T>
+  | ReadableStreamReadDoneResult<T>;
+interface ReadableStreamDefaultReader<R = any> {
+  readonly closed: Promise<void>;
+  cancel(reason?: any): Promise<void>;
+  read(): Promise<ReadableStreamReadResult<R>>;
+  releaseLock(): void;
+}
+interface UnderlyingSource<R = any> {
+  cancel?: ReadableStreamErrorCallback;
+  pull?: ReadableStreamDefaultControllerCallback<R>;
+  start?: ReadableStreamDefaultControllerCallback<R>;
+  type?: undefined;
+}
+interface ReadableStreamErrorCallback {
+  (reason: any): void | PromiseLike<void>;
+}
+interface ReadableStreamDefaultControllerCallback<R> {
+  (controller: ReadableStreamDefaultController<R>): void | PromiseLike<void>;
+}
+interface ReadableStreamDefaultController<R> {
+  readonly desiredSize: number;
+  enqueue(chunk?: R): void;
+  close(): void;
+  error(e?: any): void;
+}
+interface ReadableStream<R = any> {
+  readonly locked: boolean;
+  cancel(reason?: any): Promise<void>;
+  getReader(): ReadableStreamDefaultReader<R>;
+  tee(): [ReadableStream<R>, ReadableStream<R>];
+}
+declare const ReadableStream: {
+  prototype: ReadableStream;
+  new <R = any>(src?: UnderlyingSource<R>): ReadableStream<R>;
+};
+interface WritableStream<W = any> {
+  readonly locked: boolean;
+  abort(reason?: any): Promise<void>;
+  getWriter(): WritableStreamDefaultWriter<W>;
+}
+interface WritableStreamDefaultWriter<W = any> {
+  readonly closed: Promise<void>;
+  readonly desiredSize: number | null;
+  readonly ready: Promise<void>;
+  abort(reason?: any): Promise<void>;
+  close(): Promise<void>;
+  releaseLock(): void;
+  write(chunk: W): Promise<void>;
+}
+interface DOMStringList {
+  readonly length: number;
+  contains(string: string): boolean;
+  item(index: number): string | null;
+  [index: number]: string;
+}
+declare class DOMException extends Error {
+  constructor(message?: string, name?: string);
+  readonly name: string;
+  readonly message: string;
+}
+declare interface Location {
+  readonly ancestorOrigins: DOMStringList;
+  hash: string;
+  host: string;
+  hostname: string;
+  href: string;
+  toString(): string;
+  readonly origin: string;
+  pathname: string;
+  port: string;
+  protocol: string;
+  search: string;
+  assign(url: string): void;
+  reload(): void;
+  replace(url: string): void;
 }
 type BufferSource = ArrayBufferView | ArrayBuffer;
 type BlobPart = BufferSource | Blob | string;
@@ -583,6 +227,17 @@ declare const Blob: {
   prototype: Blob;
   new (blobParts?: BlobPart[], options?: BlobPropertyBag): Blob;
 };
+interface FilePropertyBag extends BlobPropertyBag {
+  lastModified?: number;
+}
+interface File extends Blob {
+  readonly lastModified: number;
+  readonly name: string;
+}
+declare const File: {
+  prototype: File;
+  new (fileBits: BlobPart[], fileName: string, options?: FilePropertyBag): File;
+};
 declare const isConsoleInstance: unique symbol;
 declare class Console {
   indentLevel: number;
@@ -624,186 +279,180 @@ declare class Console {
   trace: (...args: unknown[]) => void;
   static [Symbol.hasInstance](instance: Console): boolean;
 }
-declare namespace __event {
-  export const eventAttributes: WeakMap<object, any>;
-  export class EventInit implements __domTypes.EventInit {
-    bubbles: boolean;
-    cancelable: boolean;
-    composed: boolean;
-    constructor({
-      bubbles,
-      cancelable,
-      composed,
-    }?: {
-      bubbles?: boolean | undefined;
-      cancelable?: boolean | undefined;
-      composed?: boolean | undefined;
-    });
-  }
-  export class Event implements __domTypes.Event {
-    isTrusted: boolean;
-    private _canceledFlag;
-    private _dispatchedFlag;
-    private _initializedFlag;
-    private _inPassiveListenerFlag;
-    private _stopImmediatePropagationFlag;
-    private _stopPropagationFlag;
-    private _path;
-    constructor(type: string, eventInitDict?: __domTypes.EventInit);
-    readonly bubbles: boolean;
-    cancelBubble: boolean;
-    cancelBubbleImmediately: boolean;
-    readonly cancelable: boolean;
-    readonly composed: boolean;
-    currentTarget: __domTypes.EventTarget;
-    readonly defaultPrevented: boolean;
-    dispatched: boolean;
-    eventPhase: number;
-    readonly initialized: boolean;
-    inPassiveListener: boolean;
-    path: __domTypes.EventPath[];
-    relatedTarget: __domTypes.EventTarget;
-    target: __domTypes.EventTarget;
-    readonly timeStamp: Date;
-    readonly type: string;
-    composedPath(): __domTypes.EventPath[];
-    preventDefault(): void;
-    stopPropagation(): void;
-    stopImmediatePropagation(): void;
-  }
+type FormDataEntryValue = File | string;
+interface FormData extends DomIterable<string, FormDataEntryValue> {
+  append(name: string, value: string | Blob, fileName?: string): void;
+  delete(name: string): void;
+  get(name: string): FormDataEntryValue | null;
+  getAll(name: string): FormDataEntryValue[];
+  has(name: string): boolean;
+  set(name: string, value: string | Blob, fileName?: string): void;
 }
-declare namespace __customEvent {
-  export const customEventAttributes: WeakMap<object, any>;
-  export class CustomEventInit extends __event.EventInit
-    implements __domTypes.CustomEventInit {
-    detail: any;
-    constructor({
-      bubbles,
-      cancelable,
-      composed,
-      detail,
-    }: __domTypes.CustomEventInit);
-  }
-  export class CustomEvent extends __event.Event
-    implements __domTypes.CustomEvent {
-    constructor(type: string, customEventInitDict?: __domTypes.CustomEventInit);
-    readonly detail: any;
-    initCustomEvent(
-      type: string,
-      bubbles?: boolean,
-      cancelable?: boolean,
-      detail?: any,
-    ): void;
-    readonly [Symbol.toStringTag]: string;
-  }
+declare const FormData: {
+  prototype: FormData;
+  new (): FormData;
+};
+interface Body {
+  readonly body: ReadableStream<Uint8Array> | null;
+  readonly bodyUsed: boolean;
+  arrayBuffer(): Promise<ArrayBuffer>;
+  blob(): Promise<Blob>;
+  formData(): Promise<FormData>;
+  json(): Promise<any>;
+  text(): Promise<string>;
 }
-declare namespace __eventTarget {
-  export class EventListenerOptions implements __domTypes.EventListenerOptions {
-    _capture: boolean;
-    constructor({ capture }?: { capture?: boolean | undefined });
-    readonly capture: boolean;
-  }
-  export class AddEventListenerOptions extends EventListenerOptions
-    implements __domTypes.AddEventListenerOptions {
-    _passive: boolean;
-    _once: boolean;
-    constructor({
-      capture,
-      passive,
-      once,
-    }?: {
-      capture?: boolean | undefined;
-      passive?: boolean | undefined;
-      once?: boolean | undefined;
-    });
-    readonly passive: boolean;
-    readonly once: boolean;
-  }
-  export const eventTargetAssignedSlot: unique symbol;
-  export const eventTargetHasActivationBehavior: unique symbol;
-  export class EventTarget implements __domTypes.EventTarget {
-    [__domTypes.eventTargetHost]: __domTypes.EventTarget | null;
-    [__domTypes.eventTargetListeners]: {
-      [type in string]: __domTypes.EventListener[];
-    };
-    [__domTypes.eventTargetMode]: string;
-    [__domTypes.eventTargetNodeType]: __domTypes.NodeType;
-    private [eventTargetAssignedSlot];
-    private [eventTargetHasActivationBehavior];
-    addEventListener(
-      type: string,
-      callback: __domTypes.EventListenerOrEventListenerObject | null,
-      options?: __domTypes.AddEventListenerOptions | boolean,
-    ): void;
-    removeEventListener(
-      type: string,
-      callback: __domTypes.EventListenerOrEventListenerObject | null,
-      options?: __domTypes.EventListenerOptions | boolean,
-    ): void;
-    dispatchEvent(event: __domTypes.Event): boolean;
-    readonly [Symbol.toStringTag]: string;
-  }
+type HeadersInit = Headers | string[][] | Record<string, string>;
+interface Headers {
+  append(name: string, value: string): void;
+  delete(name: string): void;
+  get(name: string): string | null;
+  has(name: string): boolean;
+  set(name: string, value: string): void;
+  forEach(
+    callbackfn: (value: string, key: string, parent: Headers) => void,
+    thisArg?: any,
+  ): void;
 }
-declare namespace __fetch {
-  class Body
-    implements
-      __domTypes.Body,
-      __domTypes.ReadableStream<Uint8Array>,
-      Deno.ReadCloser
-  {
-    readonly contentType: string;
-    bodyUsed: boolean;
-    readonly locked: boolean;
-    readonly body: __domTypes.ReadableStream<Uint8Array>;
-    constructor(rid: number, contentType: string);
-    arrayBuffer(): Promise<ArrayBuffer>;
-    blob(): Promise<Blob>;
-    formData(): Promise<__domTypes.FormData>;
-    json(): Promise<any>;
-    text(): Promise<string>;
-    read(p: Uint8Array): Promise<number | Deno.EOF>;
-    close(): void;
-    cancel(): Promise<void>;
-    getReader(options: { mode: "byob" }): __domTypes.ReadableStreamBYOBReader;
-    getReader(): __domTypes.ReadableStreamDefaultReader<Uint8Array>;
-    getReader(): __domTypes.ReadableStreamBYOBReader;
-    tee(): [__domTypes.ReadableStream, __domTypes.ReadableStream];
-    [Symbol.asyncIterator](): AsyncIterableIterator<Uint8Array>;
-  }
-  export class Response implements __domTypes.Response {
-    readonly url: string;
-    readonly status: number;
-    statusText: string;
-    readonly type: __domTypes.ResponseType;
-    readonly redirected: boolean;
-    headers: __domTypes.Headers;
-    readonly trailer: Promise<__domTypes.Headers>;
-    bodyUsed: boolean;
-    readonly body: Body;
-    constructor(
-      url: string,
-      status: number,
-      statusText: string,
-      headersList: Array<[string, string]>,
-      rid: number,
-      redirected_: boolean,
-      type_?: null | __domTypes.ResponseType,
-      body_?: null | Body,
-    );
-    arrayBuffer(): Promise<ArrayBuffer>;
-    blob(): Promise<Blob>;
-    formData(): Promise<__domTypes.FormData>;
-    json(): Promise<any>;
-    text(): Promise<string>;
-    readonly ok: boolean;
-    clone(): __domTypes.Response;
-    redirect(url: URL | string, status: number): __domTypes.Response;
-  }
-  export function fetch(
-    input: __domTypes.Request | URL | string,
-    init?: __domTypes.RequestInit,
-  ): Promise<Response>;
+interface Headers extends DomIterable<string, string> {
+  append(name: string, value: string): void;
+  delete(name: string): void;
+  entries(): IterableIterator<[string, string]>;
+  get(name: string): string | null;
+  has(name: string): boolean;
+  keys(): IterableIterator<string>;
+  set(name: string, value: string): void;
+  values(): IterableIterator<string>;
+  forEach(
+    callbackfn: (value: string, key: string, parent: this) => void,
+    thisArg?: any,
+  ): void;
+  [Symbol.iterator](): IterableIterator<[string, string]>;
+}
+declare const Headers: {
+  prototype: Headers;
+  new (init?: HeadersInit): Headers;
+};
+type RequestInfo = Request | string;
+type RequestCache =
+  | "default"
+  | "force-cache"
+  | "no-cache"
+  | "no-store"
+  | "only-if-cached"
+  | "reload";
+type RequestCredentials = "include" | "omit" | "same-origin";
+type RequestMode = "cors" | "navigate" | "no-cors" | "same-origin";
+type RequestRedirect = "error" | "follow" | "manual";
+type ReferrerPolicy =
+  | ""
+  | "no-referrer"
+  | "no-referrer-when-downgrade"
+  | "origin"
+  | "origin-when-cross-origin"
+  | "same-origin"
+  | "strict-origin"
+  | "strict-origin-when-cross-origin"
+  | "unsafe-url";
+type BodyInit =
+  | Blob
+  | BufferSource
+  | FormData
+  | URLSearchParams
+  | ReadableStream<Uint8Array>
+  | string;
+type RequestDestination =
+  | ""
+  | "audio"
+  | "audioworklet"
+  | "document"
+  | "embed"
+  | "font"
+  | "image"
+  | "manifest"
+  | "object"
+  | "paintworklet"
+  | "report"
+  | "script"
+  | "sharedworker"
+  | "style"
+  | "track"
+  | "video"
+  | "worker"
+  | "xslt";
+interface RequestInit {
+  body?: BodyInit | null;
+  cache?: RequestCache;
+  credentials?: RequestCredentials;
+  headers?: HeadersInit;
+  integrity?: string;
+  keepalive?: boolean;
+  method?: string;
+  mode?: RequestMode;
+  redirect?: RequestRedirect;
+  referrer?: string;
+  referrerPolicy?: ReferrerPolicy;
+  signal?: AbortSignal | null;
+  window?: any;
 }
+interface Request extends Body {
+  readonly cache: RequestCache;
+  readonly credentials: RequestCredentials;
+  readonly destination: RequestDestination;
+  readonly headers: Headers;
+  readonly integrity: string;
+  readonly isHistoryNavigation: boolean;
+  readonly isReloadNavigation: boolean;
+  readonly keepalive: boolean;
+  readonly method: string;
+  readonly mode: RequestMode;
+  readonly redirect: RequestRedirect;
+  readonly referrer: string;
+  readonly referrerPolicy: ReferrerPolicy;
+  readonly signal: AbortSignal;
+  readonly url: string;
+  clone(): Request;
+}
+declare const Request: {
+  prototype: Request;
+  new (input: RequestInfo, init?: RequestInit): Request;
+};
+type ResponseType =
+  | "basic"
+  | "cors"
+  | "default"
+  | "error"
+  | "opaque"
+  | "opaqueredirect";
+interface Response extends Body {
+  readonly headers: Headers;
+  readonly ok: boolean;
+  readonly redirected: boolean;
+  readonly status: number;
+  readonly statusText: string;
+  readonly trailer: Promise<Headers>;
+  readonly type: ResponseType;
+  readonly url: string;
+  clone(): Response;
+}
+declare const Response: {
+  prototype: Response;
+  new (
+    url: string,
+    status: number,
+    statusText: string,
+    headersList: Array<[string, string]>,
+    rid: number,
+    redirected_: boolean,
+    type_?: null | ResponseType,
+    body_?: null | Body,
+  ): Response;
+  error(): Response;
+  redirect(url: string, status?: number): Response;
+};
+declare function fetch(
+  input: Request | URL | string,
+  init?: RequestInit,
+): Promise<Response>;
 declare function atob(s: string): string;
 declare function btoa(s: string): string;
 declare class TextDecoder {
@@ -873,10 +522,39 @@ declare const URL: {
   createObjectURL(object: any): string;
   revokeObjectURL(url: string): void;
 };
-declare class Worker {
-  onerror?: (e: Event) => void;
-  onmessage?: (data: any) => void;
-  onmessageerror?: () => void;
+interface MessageEventInit extends EventInit {
+  data?: any;
+  origin?: string;
+  lastEventId?: string;
+}
+declare class MessageEvent extends Event {
+  readonly data: any;
+  readonly origin: string;
+  readonly lastEventId: string;
+  constructor(type: string, eventInitDict?: MessageEventInit);
+}
+interface ErrorEventInit extends EventInit {
+  message?: string;
+  filename?: string;
+  lineno?: number;
+  colno?: number;
+  error?: any;
+}
+declare class ErrorEvent extends Event {
+  readonly message: string;
+  readonly filename: string;
+  readonly lineno: number;
+  readonly colno: number;
+  readonly error: any;
+  constructor(type: string, eventInitDict?: ErrorEventInit);
+}
+interface PostMessageOptions {
+  transfer?: any[];
+}
+declare class Worker extends EventTarget {
+  onerror?: (e: ErrorEvent) => void;
+  onmessage?: (e: MessageEvent) => void;
+  onmessageerror?: (e: MessageEvent) => void;
   constructor(
     specifier: string,
     options?: {
@@ -884,9 +562,119 @@ declare class Worker {
       name?: string;
     },
   );
-  postMessage(data: any): void;
+  postMessage(message: any, transfer: ArrayBuffer[]): void;
+  postMessage(message: any, options?: PostMessageOptions): void;
   terminate(): void;
 }
 declare namespace performance {
   export function now(): number;
 }
+interface EventInit {
+  bubbles?: boolean;
+  cancelable?: boolean;
+  composed?: boolean;
+}
+declare class Event {
+  constructor(type: string, eventInitDict?: EventInit);
+  readonly bubbles: boolean;
+  cancelBubble: boolean;
+  readonly cancelable: boolean;
+  readonly composed: boolean;
+  readonly currentTarget: EventTarget | null;
+  readonly defaultPrevented: boolean;
+  readonly eventPhase: number;
+  readonly isTrusted: boolean;
+  readonly target: EventTarget | null;
+  readonly timeStamp: number;
+  readonly type: string;
+  composedPath(): EventTarget[];
+  preventDefault(): void;
+  stopImmediatePropagation(): void;
+  stopPropagation(): void;
+  readonly AT_TARGET: number;
+  readonly BUBBLING_PHASE: number;
+  readonly CAPTURING_PHASE: number;
+  readonly NONE: number;
+  static readonly AT_TARGET: number;
+  static readonly BUBBLING_PHASE: number;
+  static readonly CAPTURING_PHASE: number;
+  static readonly NONE: number;
+}
+declare class EventTarget {
+  addEventListener(
+    type: string,
+    listener: EventListenerOrEventListenerObject | null,
+    options?: boolean | AddEventListenerOptions,
+  ): void;
+  dispatchEvent(event: Event): boolean;
+  removeEventListener(
+    type: string,
+    callback: EventListenerOrEventListenerObject | null,
+    options?: EventListenerOptions | boolean,
+  ): void;
+  [Symbol.toStringTag]: string;
+}
+interface EventListener {
+  (evt: Event): void | Promise<void>;
+}
+interface EventListenerObject {
+  handleEvent(evt: Event): void | Promise<void>;
+}
+declare type EventListenerOrEventListenerObject =
+  | EventListener
+  | EventListenerObject;
+interface AddEventListenerOptions extends EventListenerOptions {
+  once?: boolean;
+  passive?: boolean;
+}
+interface EventListenerOptions {
+  capture?: boolean;
+}
+interface ProgressEvent<T extends EventTarget = EventTarget> extends Event {
+  readonly lengthComputable: boolean;
+  readonly loaded: number;
+  readonly target: T | null;
+  readonly total: number;
+}
+interface CustomEventInit<T = any> extends EventInit {
+  detail?: T;
+}
+declare class CustomEvent<T = any> extends Event {
+  constructor(typeArg: string, eventInitDict?: CustomEventInit<T>);
+  readonly detail: T;
+}
+declare class AbortController {
+  readonly signal: AbortSignal;
+  abort(): void;
+}
+interface AbortSignalEventMap {
+  abort: Event;
+}
+interface AbortSignal extends EventTarget {
+  readonly aborted: boolean;
+  onabort: ((this: AbortSignal, ev: Event) => any) | null;
+  addEventListener<K extends keyof AbortSignalEventMap>(
+    type: K,
+    listener: (this: AbortSignal, ev: AbortSignalEventMap[K]) => any,
+    options?: boolean | AddEventListenerOptions,
+  ): void;
+  addEventListener(
+    type: string,
+    listener: EventListenerOrEventListenerObject,
+    options?: boolean | AddEventListenerOptions,
+  ): void;
+  removeEventListener<K extends keyof AbortSignalEventMap>(
+    type: K,
+    listener: (this: AbortSignal, ev: AbortSignalEventMap[K]) => any,
+    options?: boolean | EventListenerOptions,
+  ): void;
+  removeEventListener(
+    type: string,
+    listener: EventListenerOrEventListenerObject,
+    options?: boolean | EventListenerOptions,
+  ): void;
+}
+declare const AbortSignal: {
+  prototype: AbortSignal;
+  new (): AbortSignal;
+};
diff --git a/lib.deno.window.d.ts b/lib.deno.window.d.ts
index aa000ab..c8da9fa 100644
--- a/lib.deno.window.d.ts
+++ b/lib.deno.window.d.ts
@@ -1,17 +1,18 @@
-declare interface Window extends WindowOrWorkerGlobalScope {
-  window: Window & WindowOrWorkerGlobalScope & typeof globalThis;
-  self: Window & WindowOrWorkerGlobalScope & typeof globalThis;
-  onload: Function | undefined;
-  onunload: Function | undefined;
+declare interface Window extends EventTarget {
+  readonly window: Window & typeof globalThis;
+  readonly self: Window & typeof globalThis;
+  onload: ((this: Window, ev: Event) => any) | null;
+  onunload: ((this: Window, ev: Event) => any) | null;
+  location: Location;
   crypto: Crypto;
   close: () => void;
-  closed: boolean;
+  readonly closed: boolean;
   Deno: typeof Deno;
 }
-declare const window: Window & WindowOrWorkerGlobalScope & typeof globalThis;
-declare const self: Window & WindowOrWorkerGlobalScope & typeof globalThis;
-declare const onload: Function | undefined;
-declare const onunload: Function | undefined;
+declare const window: Window & typeof globalThis;
+declare const self: Window & typeof globalThis;
+declare const onload: ((this: Window, ev: Event) => any) | null;
+declare const onunload: ((this: Window, ev: Event) => any) | null;
 declare const crypto: Crypto;
 declare interface Crypto {
   readonly subtle: null;
diff --git a/lib.deno.worker.d.ts b/lib.deno.worker.d.ts
index 990d920..20d084a 100644
--- a/lib.deno.worker.d.ts
+++ b/lib.deno.worker.d.ts
@@ -1,16 +1,14 @@
-declare interface DedicatedWorkerGlobalScope extends WindowOrWorkerGlobalScope {
-  self: DedicatedWorkerGlobalScope
-    & WindowOrWorkerGlobalScope
-    & typeof globalThis;
-  onmessage: (e: { data: any }) => void;
+declare interface DedicatedWorkerGlobalScope {
+  self: DedicatedWorkerGlobalScope & typeof globalThis;
+  onmessage: (e: MessageEvent) => void;
+  onmessageerror: (e: MessageEvent) => void;
+  location: Location;
   onerror: undefined | typeof onerror;
   name: typeof __workerMain.name;
   close: typeof __workerMain.close;
   postMessage: typeof __workerMain.postMessage;
 }
-declare const self: DedicatedWorkerGlobalScope
-  & WindowOrWorkerGlobalScope
-  & typeof globalThis;
+declare const self: DedicatedWorkerGlobalScope & typeof globalThis;
 declare let onmessage: ((e: { data: any }) => Promise<void> | void) | undefined;
 declare let onerror:
   | ((
